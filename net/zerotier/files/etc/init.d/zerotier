#!/bin/sh /etc/rc.common

START=90

USE_PROCD=1

PROG=/usr/bin/zerotier-one
CONFIG_PATH=/var/lib/zerotier-one

extra_command "addnat" "Add firewall rule to allow zerotier clients access your LAN network"
extra_command "delnat" "Delete firewall rule to reject zerotier clients access your LAN network"

log() {
	echo "$@"
	logger -t $(basename $initscript) "$@" # debug
}

addnat() {
	local enabled nat FW

	# Ensure that the service is enabled
	enabled="$(uci -q get zerotier.@zerotier[0].enabled)"
	if [ "$enabled" != "1" ] && ! $initscript enabled; then
		log "Service is disabled."
		return 0
	fi

	nat="$(uci -q get zerotier.@zerotier[0].nat)"
	if [ "$nat" != "1" ]; then
		log "NAT disabled in config."
		return 0
	fi

	# Wait zt tun device
	while [ "$(ifconfig | grep 'zt' | awk '{print $1}')" = "" ]
	do
		log "Waiting zt device ... "
		sleep 1
	done

	[ -x "$(command -v nft)" ] && FW="fw4" || FW="fw3"
	for i in $(ifconfig | grep 'zt' | awk '{print $1}')
	do
		if [ "$FW" = "fw3" ]; then
			if iptables -S FORWARD | grep -sq "$i"; then
				continue
			fi
			iptables -I FORWARD -i "$i" -j ACCEPT
			iptables -I FORWARD -o "$i" -j ACCEPT
			iptables -t nat -I POSTROUTING -o "$i" -j MASQUERADE
		else
			if nft list chain inet fw4 forward | grep -sq "$i"; then
				continue
			fi
			nft insert rule inet fw4 forward iifname "$i" accept
			nft insert rule inet fw4 forward oifname "$i" accept
			nft insert rule inet fw4 srcnat oifname "$i" counter masquerade
		fi
		log "Added nat rules for zt interface $i!"
	done
}

delnat() {
	local FW

	[ -x "$(command -v nft)" ] && FW="fw4" || FW="fw3"
	for i in $(ifconfig | grep 'zt' | awk '{print $1}')
	do
		if [ "$FW" = "fw3" ]; then
			iptables -D FORWARD -i "$i" -j ACCEPT 2>/dev/null
			iptables -D FORWARD -o "$i" -j ACCEPT 2>/dev/null
			iptables -t nat -D POSTROUTING -o "$i" -j MASQUERADE 2>/dev/null
		else
			chains="forward srcnat"
			for c in $chains; do
				handles=$(nft -a list chain inet fw4 $c | grep -E "$i" | cut -d'#' -f2 | cut -d' ' -f3)
				for h in $handles; do
					nft delete rule inet fw4 $c handle $h
				done
			done
		fi
		log "Removed nat rules for zt interface $i!"
	done
}

section_enabled() {
	config_get_bool enabled "$1" 'enabled' 0
	[ $enabled -ne 0 ]
}

start_instance() {
	local cfg="$1"
	local port secret config_path local_conf copy_config_path path
	local args=""

	if ! section_enabled "$cfg"; then
		echo "disabled in /etc/config/zerotier"
		return 1
	fi

	config_get config_path $cfg 'config_path'
	config_get port $cfg 'port'
	config_get secret $cfg 'secret'
	config_get local_conf $cfg 'local_conf'
	config_get_bool copy_config_path $cfg 'copy_config_path' 0

	path=${CONFIG_PATH}_$cfg

	# Remove existing link or folder
	rm -rf $path

	# Create link or copy files from CONFIG_PATH to config_path
	if [ -n "$config_path" -a "$config_path" != "$path" ]; then
		# Create the config path to init and persist
		if [ ! -d "$config_path" ]; then
			echo "ZeroTier config_path does not exist: $config_path, create..."
			mkdir -p $config_path
		fi

		# ensure that the target exists
		mkdir -p $(dirname $path)

		if [ "$copy_config_path" = "1" ]; then
			cp -r $config_path $path
		else
			ln -s $config_path $path
		fi
	fi

	mkdir -p $path/networks.d

	# link latest default config path to latest config path
	rm -f $CONFIG_PATH
	ln -s $path $CONFIG_PATH

	if [ -n "$port" ]; then
		args="$args -p${port}"
	fi

	if [ -z "$secret" -a ! -f $path/identity.secret ]; then
		echo "Generate secret - please wait..."
		local sf="/tmp/zt.$cfg.secret"

		zerotier-idtool generate "$sf" > /dev/null
		[ $? -ne 0 ] && return 1

		secret="$(cat $sf)"
		rm "$sf"

		uci set zerotier.$cfg.secret="$secret"
		uci commit zerotier
	fi

	if [ -n "$secret" ]; then
		echo "$secret" > $path/identity.secret
		# make sure there is not previous identity.public
		rm -f $path/identity.public
	fi

	if [ -f "$local_conf" ]; then
		ln -s "$local_conf" $path/local.conf
	fi

	add_join() {
		# an (empty) config file will cause ZT to join a network
		touch $path/networks.d/$1.conf
	}

	config_list_foreach $cfg 'join' add_join

	procd_open_instance
	procd_set_param command $PROG $args $path
	procd_set_param stderr 1
	procd_set_param respawn
	procd_close_instance
}

start_service() {
	config_load 'zerotier'
	config_foreach start_instance 'zerotier'

	# Wait service running
	sleep 1

	# Add NAT rules
	# Run in background, let service start
	addnat &
}

stop_instance() {
	local cfg="$1"

	# Remove existing networks
	rm -f ${CONFIG_PATH}_${cfg}/networks.d/*.conf

	# Remove existing link or folder
	rm -rf ${CONFIG_PATH}_${cfg}
}

stop_service() {
	# Remove NAT rules
	delnat

	config_load 'zerotier'
	config_foreach stop_instance 'zerotier'
	rm -f ${CONFIG_PATH}
}

reload_service() {
	stop
	start
}

service_triggers() {
	procd_add_reload_trigger 'zerotier'
}

#!/bin/sh /etc/rc.common

# This script is part of the static-device-names package.
# See /usr/share/doc/static-device-names
#
# Copyright (C) 2024 qualIP Software.
# Released under the GPL v3.0 or later.
#
# Location: /etc/init.d/static-device-names

START=11
NAME=static-device-names
TRACE=${TRACE:-0}

# don't run within buildroot
[ -n "${IPKG_INSTROOT}" ] && return 0

###################
# LOCAL FUNCTIONS #
###################

N=$'\n'  # New line

LOG() {
  local level ; level=$1 ; shift
  [ "$level" = "debug" ] && [ "$TRACE" = 0 ] && return
  logger -s -t "$NAME" -p "syslog.$level" -- "$@"
}

target_devices=
mac_to_device_mapping=
pci_id_to_device_mapping=
pci_slot_to_device_mapping=
usb_slot_to_device_mapping=

## Read configuration using UCI
read_static_device_names_config() {
  local rc=0
  local dev
  local mac
  local pci_id
  local pci_slot
  local usb_slot
  if [ -z "$target_devices" ] ; then
    target_devices=
    mac_to_device_mapping=
    pci_id_to_device_mapping=
    pci_slot_to_device_mapping=
    usb_slot_to_device_mapping=
    local i=0
    while uci -q get "static-device-names.@device[$i]" > /dev/null ; do
      dev=$(uci -q get "static-device-names.@device[$i].name")
      if [ -n "$dev" ] ; then
        target_devices="$target_devices$N$dev"
        for mac in $(uci -q get "static-device-names.@device[$i].mac") ; do
          mac_to_device_mapping="${mac_to_device_mapping:+$mac_to_device_mapping$N}$mac $dev"
        done
        for pci_id in $(uci -q get "static-device-names.@device[$i].pci_id") ; do
          pci_id_to_device_mapping="${pci_id_to_device_mapping:+$pci_id_to_device_mapping$N}$pci_id $dev"
        done
        for pci_slot in $(uci -q get "static-device-names.@device[$i].pci_slot") ; do
          pci_slot_to_device_mapping="${pci_slot_to_device_mapping:+$pci_slot_to_device_mapping$N}$pci_slot $dev"
        done
        for usb_slot in $(uci -q get "static-device-names.@device[$i].usb_slot") ; do
          usb_slot_to_device_mapping="${usb_slot_to_device_mapping:+$usb_slot_to_device_mapping$N}$usb_slot $dev"
        done
      else
        LOG err "Configuration static-device-names.@device[$i] mission option 'name'"
        rc=1
      fi
      i=$((i+1))
    done
    target_devices="$(echo "$target_devices" | sort -u)"
    LOG debug config: target_devices: $target_devices
    LOG debug config: mac_to_device_mapping: $mac_to_device_mapping
    LOG debug config: pci_id_to_device_mapping: $pci_id_to_device_mapping
    LOG debug config: pci_slot_to_device_mapping: $pci_slot_to_device_mapping
    LOG debug config: usb_slot_to_device_mapping: $usb_slot_to_device_mapping
  fi
  return $rc
}

## Gets the subsystem of a device.
# Usage: get_device_subsystem <dev>
# Returns: "pci", "usb", ...
get_device_subsystem() {
  local dev ; dev=$1 ; shift
  basename "$(readlink -f "/sys/class/net/$dev/device/subsystem")"
}

## Gets the MAC of a device.
# Usage: get_device_mac <dev>
get_device_mac() {
  local dev ; dev=$1 ; shift
  cat "/sys/class/net/$dev/address"
}

## Gets the PCI ID of a device in <vendor>:<device> form.
# Usage: get_device_pci_id <dev>
get_device_pci_id() {
  local dev ; dev=$1 ; shift
  if [ -f "/sys/class/net/$dev/device/subsystem_vendor" ] ; then
    # e.g., PCI
    echo $(cat "/sys/class/net/$dev/device/subsystem_vendor"):$(cat "/sys/class/net/$dev/device/subsystem_device") | sed -e 's/0x//g'
  elif [ -f "/sys/class/net/$dev/device/../idProduct" ] ; then
    # e.g., USB
    echo $(cat "/sys/class/net/$dev/device/../idVendor"):$(cat "/sys/class/net/$dev/device/../idProduct") | sed -e 's/0x//g'
  fi
}

## Gets the PCI slot of a device.
# Usage: get_device_pci_slot <dev>
get_device_pci_slot() {
  local dev ; dev=$1 ; shift
  if [ $(get_device_subsystem "$dev") = "pci" ] ; then
    # 0000:07:00.0
    local pci_slot ; pci_slot=$(basename "$(readlink -f "/sys/class/net/$dev/device")")
    # Remove default domain
    pci_slot=${pci_slot#0000:}  # 07:00.0
    echo "$pci_slot"
  fi
}

## Gets the USB slot of a device in <bus>-<port>:<port>.<if> form.
# Usage: get_device_usb_slot <dev>
get_device_usb_slot() {
  local dev ; dev=$1 ; shift
  if [ $(get_device_subsystem "$dev") = "usb" ] ; then
    if [ -d "/sys/class/net/$dev/device" ] ; then
      basename $(readlink -f "/sys/class/net/$dev/device")
    fi
  fi
}

## Gets a string of information about a device.
# Usage: get_device_info_str <dev>
get_device_info_str() {
  local dev ; dev=$1 ; shift
  local info=
  local mac ; mac=$(get_device_mac "$dev")
  [ -n "$mac" ] && info="${info:+$info }mac=$mac"
  local pci_id ; pci_id=$(get_device_pci_id "$dev")
  [ -n "$pci_id" ] && info="${info:+$info }pci_id=$pci_id"
  local pci_slot ; pci_slot=$(get_device_pci_slot "$dev")
  [ -n "$pci_slot" ] && info="${info:+$info }pci_slot=$pci_slot"
  local usb_slot ; usb_slot=$(get_device_usb_slot "$dev")
  [ -n "$usb_slot" ] && info="${info:+$info }usb_slot=$usb_slot"
  echo "$dev ($info)"
}

## Gets the target device name.
# Usage: get_target_device_name <dev>
get_target_device_name() {
  local in_dev ; in_dev=$1 ; shift

  # Match device by MAC address
  local mac ; mac=$(get_device_mac "$in_dev")
  if [ -n "$mac" ] ; then
    dev=$(echo "$mac_to_device_mapping" | grep -i -- "^$mac " | awk '{print $2}' | head -n 1)
    if [ -n "$dev" ] ; then
      echo "$dev"
      return
    fi
  fi

  # Match device by PCI ID
  local pci_id ; pci_id=$(get_device_pci_id "$in_dev")
  if [ -n "$pci_id" ] ; then
    dev=$(echo "$pci_id_to_device_mapping" | grep -i -- "^$pci_id " | awk '{print $2}' | head -n 1)
    if [ -n "$dev" ] ; then
      echo "$dev"
      return
    fi
  fi

  # Match device by PCI slot
  local pci_slot ; pci_slot=$(get_device_pci_slot "$in_dev")
  if [ -n "$pci_slot" ] ; then
    dev=$(echo "$pci_slot_to_device_mapping" | grep -i -- "^$pci_slot " | awk '{print $2}' | head -n 1)
    if [ -n "$dev" ] ; then
      echo "$dev"
      return
    fi
  fi

  # Match device by USB slot
  local usb_slot ; usb_slot=$(get_device_usb_slot "$in_dev")
  if [ -n "$usb_slot" ] ; then
    dev=$(echo "$usb_slot_to_device_mapping" | grep -i -- "^$usb_slot " | awk '{print $2}' | head -n 1)
    if [ -n "$dev" ] ; then
      echo "$dev"
      return
    fi
  fi

  LOG debug "No target device name for $in_dev: mac=$mac, pci_id=$pci_id, pci_slot=$pci_slot, usb_slot=$usb_slot"
}

## Returns whether the device has a known target device name.
# Usage: is_known_target_device <dev>
is_known_target_device() {
  local dev ; dev=$1 ; shift
  echo "$target_devices" | grep -q "^$dev$"
}

## Lists all network devices on the system.
# Usage: list_devices [pattern]
list_devices() {
  local pattern=${1:-*}
  local path
  local dev
  for path in $(echo /sys/class/net/$pattern/device/uevent) ; do
    [[ -e "$path" ]] || continue  # no nullglob
    dev=$(echo "$path" | awk -F '/' '{print $5}')
    echo "$dev"
  done
}

## Returns whether the device exists
# Usage: device_exists <dev>
device_exists() {
  local dev ; dev=$1 ; shift
  [ -d "/sys/class/net/$dev" ]
}

## Gets the next device name available for a prefix
# Usage: get_next_device_name <prefix>
get_next_device_name() {
  local prefix ; prefix=$1 ; shift
  local dev
  local i=1
  while true ; do
    dev=$prefix$i
    device_exists "$dev" || break
    i=$((i+1))
  done
  echo "$dev"
}

## Renames the device.
# Usage: rename_device <old-dev> <new-dev>
rename_device() {
  local dev ; dev=$1 ; shift
  local new_dev ; new_dev=$1 ; shift
  if device_exists "$new_dev" ; then
    LOG err "Cannot rename device $(get_device_info_str "$dev"): $new_dev already exists"
    return 1
  fi
  ip link set "$dev" down
  ip link set "$dev" name "$new_dev"
}

###########
# ACTIONS #
###########

start() {
  local rc=0
  local devtype
  read_static_device_names_config

  # First pass on all devices.
  # Either rename or move aside with "tmp" prefix.
  for in_dev in $(list_devices) ; do
    dev=$(get_target_device_name "$in_dev")

    if [ "$in_dev" = "$dev" ] ; then
      # Already the correct device name.
      LOG info "Device $(get_device_info_str "$in_dev") has correct name"
      continue
    fi

    if [ -n "$dev" ] && ! device_exists "$dev" ; then
      # Target name is free: Rename
      LOG notice "Renaming device $(get_device_info_str "$in_dev") to $dev"
      rename_device "$in_dev" "$dev" || rc=1
      continue
    fi

    case "$in_dev" in
      tmp*)
        : # Already a temporary name: Retry in next passes
        continue
        ;;
    esac

    if [ -z "$dev" ] && ! is_known_target_device "$in_dev" ; then
      # Unknown device that does not cause a collision: Leave alone
      LOG info "Ignoring unknown device $(get_device_info_str "$in_dev")"
      continue
    fi

    # Move aside with "tmp" prefix and retry in next passes
    devtype=$(echo "$in_dev" | sed -e 's/[0-9].*//' -e 's/^tmp//')
    dev="$(get_next_device_name "tmp$devtype")"
    LOG notice "Temporarily renaming device $(get_device_info_str "$in_dev") to $dev"
    rename_device "$in_dev" "$dev" || rc=1
  done

  # Second pass on "tmp" devices.
  # Second chance to rename.
  for in_dev in $(list_devices "tmp*") ; do
    dev=$(get_target_device_name "$in_dev")
    if [ -n "$dev" ] ; then
      # Known device: Rename
      LOG notice "Renaming device $(get_device_info_str "$in_dev") to $dev"
      rename_device "$in_dev" "$dev" || rc=1
    fi
  done

  # Third pass on "tmp" devices.
  # Rename with original prefix but a free device number.
  for in_dev in $(list_devices "tmp*") ; do
    # Unknown device: Remove free name of correct prefix
    devtype=$(echo "$in_dev" | sed -e 's/[0-9].*//' -e 's/^tmp//')
    dev=$(get_next_device_name "$devtype")
    LOG notice "Renaming unknown device $(get_device_info_str "$in_dev") to $dev"
    rename_device "$in_dev" "$dev" || rc=1
  done

  return $rc
}

extra_command "status" "Service status"  # Not a default without USE_PROCD

status() {
  read_static_device_names_config
  for in_dev in $(list_devices) ; do
    dev=$(get_target_device_name "$in_dev")
    if [ -z "$dev" ] ; then
      LOG warning "$(get_device_info_str "$in_dev") unknown"
    elif [ "$in_dev" == "$dev" ] ; then
      LOG info "$(get_device_info_str "$in_dev")"
    else
      LOG error "$(get_device_info_str "$in_dev") != $dev"
    fi
  done
}

# hotplug command called by /etc/hotplug.d/net/static-device-names
extra_command "hotplug" "Service hotplug"

hotplug() {
  local DEVICENAME ; DEVICENAME=$1
  # For now, just reload
  reload
}

extra_command "debug" "Service debug"

debug() {
  # Disable logging to syslog. Send all to stderr.
  LOG() {
    local level ; level=$1 ; shift
    echo "$level: $*" >&2
  }
  LOG debug "/etc/config/static-device-names:$N~~~$N$(cat /etc/config/static-device-names)$N~~~"
  status
}
